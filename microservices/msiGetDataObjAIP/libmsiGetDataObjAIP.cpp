/*
 * libmsiGetDataObjAIP.cpp
 */



// =-=-=-=-=-=-=-
#include "eraUtil.h"
#include "msParam.hpp"
#include "reGlobalsExtern.hpp"
#include "irods_ms_plugin.hpp"
#include "irods_server_api_call.hpp"
#include "microservice.hpp"


extern "C"{
/**
 * \fn msiGetDataObjAIP(msParam_t *inpParam, msParam_t *outParam, ruleExecInfo_t *rei)
 *
 * \brief This microservice gets the Archival Information Package of a data object.
 *
 * \module ERA
 *
 * \since pre-2.1
 *
 * \author  Antoine de Torcy
 * \date   2007-09-26
 *
 * \note The results are returned as an XML file.
 *
 * \usage See clients/icommands/test/rules3.0/
 *
 * \param[in] inpParam - A DataObjInp_MS_T or a STR_MS_T with the iRODS path of the target object.
 * \param[out] outParam - A BUF_LEN_MS_T containing the results.
 * \param[in,out] rei - The RuleExecInfo structure that is automatically
 *    handled by the rule engine. The user does not include rei as a
 *    parameter in the rule invocation.
 *
 * \DolVarDependence None
 * \DolVarModified None
 * \iCatAttrDependence None
 * \iCatAttrModified None
 * \sideeffect None
 *
 * \return integer
 * \retval 0 on success
 * \pre None
 * \post None
 * \sa None
**/
int
msiGetDataObjAIP(msParam_t *inpParam, msParam_t *outParam, ruleExecInfo_t *rei)
{
   rsComm_t *rsComm; 
   dataObjInp_t dataObjInp, *myDataObjInp;
   bytesBuf_t *mybuf;

   genQueryInp_t genQueryInp;
   genQueryOut_t *genQueryOut;
   int i1a[30];
   int i1b[30];
   int i2a[30];
   char *condVal[30];
   char v1[MAX_NAME_LEN];
   char v2[MAX_NAME_LEN];
   char fullName[MAX_NAME_LEN];
   char myDirName[MAX_NAME_LEN];
   char myFileName[MAX_NAME_LEN];
   int printCount=0, i;
   char *tags[30];

   char tmpStr[MAX_NAME_LEN];
   rodsObjStat_t *rodsObjStatOut;

   RE_TEST_MACRO ("    Calling GetDataObjAIP")

   if (rei == NULL || rei->rsComm == NULL) {
	rodsLog (LOG_ERROR,
	  "msiGetDataObjAIP: input rei or rsComm is NULL");
	return (SYS_INTERNAL_NULL_INPUT_ERR);
   }

   rsComm = rei->rsComm;

   /* parse inpParam1 */
   rei->status = parseMspForDataObjInp (inpParam, &dataObjInp, &myDataObjInp, 0);

   if (rei->status < 0) {
	rodsLogAndErrorMsg (LOG_ERROR, &rsComm->rError, rei->status,
          "msiGetDataObjAIP: input inpParam1 error. status = %d", rei->status);
	return (rei->status);
   }

   /* Extract cwd name and object name */
   strncpy(fullName, myDataObjInp->objPath, MAX_NAME_LEN);
   rei->status = splitPathByKey(fullName, myDirName, MAX_NAME_LEN, myFileName, MAX_NAME_LEN, '/');


   /* buffer init */
   mybuf = (bytesBuf_t *)malloc(sizeof(bytesBuf_t));
   memset (mybuf, 0, sizeof (bytesBuf_t));


   /* Prepare XML output */
   appendStrToBBuf(mybuf, "<?xml version='1.0' encoding='utf-8'?>\n");
   appendStrToBBuf(mybuf, "<!-- Generated by SDSC iRODS (http://www.irods.org) -->\n");
   appendStrToBBuf(mybuf, "<AIP>\n");


   /* First we're going to query the ICAT for system metadata */
   tags[0]=strdup("");
   tags[1]=strdup("D_DATA_ID");
   tags[2]=strdup("D_COLL_ID");
   tags[3]=strdup("DATA_NAME");
   tags[4]=strdup("DATA_REPL_NUM");
   tags[5]=strdup("DATA_VERSION");
   tags[6]=strdup("DATA_TYPE_NAME");
   tags[7]=strdup("DATA_SIZE");
   tags[8]=strdup("D_RESC_GROUP_NAME");
   tags[9]=strdup("D_RESC_NAME");
   tags[10]=strdup("D_DATA_PATH");
   tags[11]=strdup("D_OWNER_NAME");
   tags[12]=strdup("D_OWNER_ZONE");
   tags[13]=strdup("D_REPL_STATUS");
   tags[14]=strdup("D_DATA_STATUS");
   tags[15]=strdup("D_DATA_CHECKSUM");
   tags[16]=strdup("D_EXPIRY");
   tags[17]=strdup("D_MAP_ID");
   tags[18]=strdup("D_COMMENTS");
   tags[19]=strdup("D_CREATE_TIME");
   tags[20]=strdup("D_MODIFY_TIME");


   memset (&genQueryInp, 0, sizeof (genQueryInp_t));

   i1a[0]=COL_D_DATA_ID;
   i1a[1]=COL_D_COLL_ID;
   i1a[2]=COL_DATA_NAME;
   i1a[3]=COL_DATA_REPL_NUM;
   i1a[4]=COL_DATA_VERSION;
   i1a[5]=COL_DATA_TYPE_NAME;
   i1a[6]=COL_DATA_SIZE;
   i1a[7]=COL_D_RESC_HIER;
   i1a[8]=COL_D_RESC_NAME;
   i1a[9]=COL_D_DATA_PATH;
   i1a[10]=COL_D_OWNER_NAME;
   i1a[11]=COL_D_OWNER_ZONE;
   i1a[12]=COL_D_REPL_STATUS;
   i1a[13]=COL_D_DATA_STATUS;
   i1a[14]=COL_D_DATA_CHECKSUM;
   i1a[15]=COL_D_EXPIRY;
   i1a[16]=COL_D_MAP_ID;
   i1a[17]=COL_D_COMMENTS;
   i1a[18]=COL_D_CREATE_TIME;
   i1a[19]=COL_D_MODIFY_TIME;

   for (i=0; i<20; i++) {
   i1b[i]=0; /* currently unused */
   }

   genQueryInp.selectInp.inx = i1a;
   genQueryInp.selectInp.value = i1b;
   genQueryInp.selectInp.len = 20;


   i2a[0]=COL_COLL_NAME;
   sprintf(v1,"='%s'",myDirName);
   condVal[0]=v1;

   i2a[1]=COL_DATA_NAME;
   sprintf(v2,"='%s'",myFileName);
   condVal[1]=v2;

   genQueryInp.sqlCondInp.inx = i2a;
   genQueryInp.sqlCondInp.value = condVal;
   genQueryInp.sqlCondInp.len=2;

   genQueryInp.maxRows=30;
   genQueryInp.continueInx=0;
   genQueryInp.condInput.len=0;


   /* First rsGenQuery() call for system metadata */
   rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);




   /* Parse and print out results */
   if (rei->status == CAT_NO_ROWS_FOUND) {
      i1a[0]=COL_D_DATA_PATH;
      genQueryInp.selectInp.len = 1;
      rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);
      if (rei->status==0) {
    	  freeGenQueryOut (&genQueryOut);
      }
      if (rei->status == CAT_NO_ROWS_FOUND) {

	rodsLogAndErrorMsg (LOG_ERROR, &rsComm->rError, rei->status,
          "msiGetDataObjAIP: DataObject %s not found. status = %d", fullName, rei->status);
	return (rei->status);
      }
      printCount+=genQueryOutToXML(genQueryOut, mybuf, tags);
   }
   else {
      printCount+=genQueryOutToXML(genQueryOut, mybuf, tags);
   }

   while (rei->status==0 && genQueryOut && genQueryOut->continueInx > 0) {
      genQueryInp.continueInx=genQueryOut->continueInx;
      rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);
      printCount+= genQueryOutToXML(genQueryOut, mybuf, tags);
   }


  /* Now we're going to query the ICAT for user defined metadata. One hit = one AVU triplet */
   tags[0]=strdup("AVU");
   tags[1]=strdup("attribute");
   tags[2]=strdup("value");
   tags[3]=strdup("units");

   memset (&genQueryInp, 0, sizeof (genQueryInp_t));

   i1a[0]=COL_META_DATA_ATTR_NAME;
   i1b[0]=0; /* currently unused */
   i1a[1]=COL_META_DATA_ATTR_VALUE;
   i1b[1]=0; /* currently unused */
   i1a[2]=COL_META_DATA_ATTR_UNITS;
   i1b[2]=0; /* currently unused */
   genQueryInp.selectInp.inx = i1a;
   genQueryInp.selectInp.value = i1b;
   genQueryInp.selectInp.len = 3;

   /* Extract cwd name and object name */
   strncpy(fullName, myDataObjInp->objPath, MAX_NAME_LEN);
   rei->status = splitPathByKey(fullName, myDirName, MAX_NAME_LEN, myFileName, MAX_NAME_LEN, '/');

   i2a[0]=COL_COLL_NAME;
   sprintf(v1,"='%s'",myDirName);
   condVal[0]=v1;

   i2a[1]=COL_DATA_NAME;
   sprintf(v2,"='%s'",myFileName);
   condVal[1]=v2;


   genQueryInp.sqlCondInp.inx = i2a;
   genQueryInp.sqlCondInp.value = condVal;
   genQueryInp.sqlCondInp.len=2;

   genQueryInp.maxRows=10;
   genQueryInp.continueInx=0;
   genQueryInp.condInput.len=0;

   /* rsGenQuery() call for user defined metadata */
   rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);

   /* Parse and print out results */
   if (rei->status == CAT_NO_ROWS_FOUND) {
      i1a[0]=COL_D_DATA_PATH;
      genQueryInp.selectInp.len = 1;
      rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);
      if (rei->status==0) {
    	  freeGenQueryOut (&genQueryOut);
      }
      if (rei->status == CAT_NO_ROWS_FOUND) {

	rodsLogAndErrorMsg (LOG_ERROR, &rsComm->rError, rei->status,
          "msiGetDataObjAVUs: DataObject %s not found. status = %d", fullName, rei->status);
	return (rei->status);
      }
      printCount+=genQueryOutToXML(genQueryOut, mybuf, tags);
   }
   else {
      printCount+=genQueryOutToXML(genQueryOut, mybuf, tags);
   }

   while (rei->status==0 && genQueryOut && genQueryOut->continueInx > 0) {
      genQueryInp.continueInx=genQueryOut->continueInx;
      rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);
      printCount+= genQueryOutToXML(genQueryOut, mybuf, tags);
   }

    /* Same thing again, but this time for user access */
    tags[0]=strdup("ACL");
    tags[1]=strdup("COL_DATA_ACCESS_TYPE");
    tags[2]=strdup("COL_DATA_ACCESS_NAME");
    tags[3]=strdup("COL_DATA_TOKEN_NAMESPACE");
    tags[4]=strdup("COL_DATA_ACCESS_USER_IDM");
    tags[5]=strdup("COL_DATA_ACCESS_DATA_ID");

    memset (&genQueryInp, 0, sizeof (genQueryInp_t));

    rei->status = rsObjStat(rsComm, &dataObjInp, &rodsObjStatOut);

    addInxIval (&genQueryInp.selectInp, COL_USER_NAME, 1);
    addInxIval (&genQueryInp.selectInp, COL_DATA_ACCESS_NAME, 1);

    snprintf (tmpStr, MAX_NAME_LEN, " = '%s'", rodsObjStatOut->dataId);

    addInxVal (&genQueryInp.sqlCondInp, COL_DATA_ACCESS_DATA_ID, tmpStr);

    snprintf (tmpStr, MAX_NAME_LEN, "='%s'", "access_type");

    /* Currently necessary since other namespaces exist in the token table */
    addInxVal (&genQueryInp.sqlCondInp, COL_DATA_TOKEN_NAMESPACE, tmpStr);

    genQueryInp.maxRows = MAX_SQL_ROWS;

    rei->status =  rsGenQuery (rsComm, &genQueryInp, &genQueryOut);

   /* Parse and print out results */
   if (rei->status == CAT_NO_ROWS_FOUND) {
      i1a[0]=COL_D_DATA_PATH;
      genQueryInp.selectInp.len = 1;
      rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);
      if (rei->status==0) {
    	  freeGenQueryOut (&genQueryOut);
      }
      if (rei->status == CAT_NO_ROWS_FOUND) {

	rodsLogAndErrorMsg (LOG_ERROR, &rsComm->rError, rei->status,
          "msiGetDataObjAIP: DataObject %s not found. status = %d", fullName, rei->status);
	return (rei->status);
      }
      printCount+=genQueryOutToXML(genQueryOut, mybuf, tags);
   }
   else {
      printCount+=genQueryOutToXML(genQueryOut, mybuf, tags);
   }

   while (rei->status==0 && genQueryOut && genQueryOut->continueInx > 0) {
      genQueryInp.continueInx=genQueryOut->continueInx;
      rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);
      printCount+= genQueryOutToXML(genQueryOut, mybuf, tags);
   }


  /* Closing tag */
  appendStrToBBuf(mybuf, "</AIP>\n");


  fillBufLenInMsParam (outParam, strlen((char*)mybuf->buf), mybuf);

  return (rei->status);

}
irods::ms_table_entry * plugin_factory() {
    irods::ms_table_entry* msvc = new irods::ms_table_entry(2);
    msvc->add_operation("msiGetDataObjAIP","msiGetDataObjAIP");
    return msvc;
}
}
